<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>Wrap-Around Worlds - Manual - by Experilous</title>
		<style type="text/css">
			<!--/*--><![CDATA[/*><!--*/
			html
			{
				margin: 0;
				padding: 0;
			}
			
			body
			{
				margin: 0 auto;
				padding: 36pt 72pt;
				max-width: 540pt;
			}
			
			section
			{
				margin: 0;
				padding: 0;
			}
			
			h1
			{
				margin: 0;
				padding: 0;
				font-size: 200%;
			}
			
			h2
			{
				font-size: 175%;
			}
			
			h3
			{
				font-size: 150%;
			}
			
			h4
			{
				font-size: 125%;
			}
			
			h1 div.title
			{
				font-size: 100%;
			}
			
			h1 div.subtitle
			{
				font-size: 75%;
			}
			
			section.chapter:first-of-type
			{
				counter-reset: section;
			}
			
			section.chapter
			{
				counter-increment: section;
			}
			
			section.chapter section:first-of-type
			{
				counter-reset: section;
			}

			section.chapter section
			{
				counter-increment: section;
			}
			
			*.section-head:before
			{
				content: counters(section, ".") ". ";
			}
			
			dt
			{
				display: list-item;
				list-style-type: disc;
				margin-left: 1em;
				font-weight: bold;
				font-style: italic;
			}
			/*]]>*/-->
		</style>
	</head>
	<body>
		<section id="introduction">
			<h1>
				<div class="title">Wrap-Around Worlds, by <a href="http://experilous.com" target="experilous">Experilous</a></div>
				<div class="subtitle">User's Manual</div>
			</h1>
			<p>Wrap-Around Worlds is a framework to aid in the creation of game worlds which do not simply end at their borders,
				but allow game objects or effects passing across the borders to wrap around to the other side of the world.
				The framework can handle cylindrical worlds (such as those found in the Civilization series) or toroidal or "doughnut shaped" worlds (such as the screen space in Asteroids).</p>
			<p>The framework is able to manage not just the actual position and wrapping behavior of game objects,
				but also the rendering of meshes, lights, and shadows and the detection and proper handling of physical or trigger collisions across all wrapped boundaries of a world.</p>
			<p>Both orthographic and perspective cameras are supported, and the perspective camera can even render an infinitely repeating world all the way out to the horizon, limited only by the far clipping plane.<p>
		</section>
		<section id="contents">
			<h2>Contents</h2>
			<ol>
				<li><a href="#quick-start">Quick Start</a></li>
					<ol>
						<li><a href="#examples">Example Scenes</a></li>
						<li><a href="#create-your-own">Creating Your Own World</a></li>
					</ol>
				<li><a href="#worlds">Worlds</a>
					<ol>
						<li><a href="#rhomboid-world">Rhomboid World</a></li>
					</ol>
				</li>
				<li><a href="#viewports">Viewports</a></li>
				<li><a href="#ghosts">Ghosts &amp; Ghost Regions</a></li>
				<li><a href="#elements">Elements</a>
					<ol>
						<li><a href="#renderable-elements">Renderable Elements</a></li>
						<li><a href="#light-elements">Light Elements</a></li>
						<li><a href="#collider-elements">Collider Elements</a></li>
						<li><a href="#rigidbody-elements">Rigidbody Elements</a></li>
					</ol>
				</li>
				<li><a href="#wrappers">Wrappers</a></li>
				<li><a href="#bounds">Bounds</a></li>
				<li><a href="#providers-consumers">Providers &amp; Consumers</a></li>
				<li><a href="#execution-order">Execution Order</a></li>
				<li><a href="#tile-based">Integration with Tile-Based Worlds</a></li>
			</ol>
		</section>
		<section class="chapter" id="quick-start">
			<h2 class="section-head">Quick Start</h2>
			<section id="examples">
				<h2 class="section-head">Example Scenes</h2>
				<p>Included in this package are example scenes to demonstrate some of the worlds that the framework can manage.
					These scenes can be found in the <a href="Experilous/Examples/Wrap-Around Worlds/">&lt;project&gt;/Assets/Experilous/Examples/Wrap-Around Worlds/</a> folder.</p>
				<dl>
					<dt><a href="Experilous/Examples/Wrap-Around Worlds/Space Rocks.unity">Space Rocks</a></dt>
					<dd>A simple Asteroids clone, with asteroids entering from all sides of the screen, and only wrapping once fully visible.</dd>
					<dt><a href="Experilous/Examples/Wrap-Around Worlds/Dynamic Physics.unity">Dynamic Physics</a></dt>
					<dd>A small square world with dynamic rigidbody elements, some of which are able to collide with each other across world boundaries.</dd>
					<dt><a href="Experilous/Examples/Wrap-Around Worlds/Lighting and Static Physics.unity">Lighting and Static Physics</a></dt>
					<dd>A small square world with a simple player model and scattered bushes, with lighting and shadows that are able to wrap around across world boundaries.</dd>
				</dl>
				<p>If you also have access to the Tile-Based Worlds framework and import
					<a href="Experilous/Packages/Tile-Based Wrap-Around Integration - With Examples.unitypackage">Tile-Based Wrap-Around Integration - With Examples&#8203;.unitypackage</a>,
					then you will gain access to a few more example scenes.</p>
				<dl>
					<dt><a href="Experilous/Examples/Tile-Based Wrap-Around Worlds/Planar Hex Grid Horizontal Wrap.unity">Planar Hex Grid Horizontal Wrap</a></dt>
					<dd>A pre-generated planar surface with hexagonal tiles arranged at an angle to create a parallelogram-shaped world.  The world wraps around across the left and right edges.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Wrap-Around Worlds/Planar Random Grid Full Wrap.unity">Planar Random Grid Full Wrap</a></dt>
					<dd>A pre-generated planar surface with randomly shaped tiles which began as hexagonal tiles before being randomized.  The world wraps around both across the top and bottom edges and across the left and right edges.</dd>
				</dl>
			</section>
			<section id="create-your-own">
				<h2 class="section-head">Creating Your Own World</h2>
				<p>To create your own scene containing a wrap-around world, you need three basic items:  a world, a viewport, and one or more elements which participate with the wrapping behavior in some manner.</p>
				<p>The world can be created by placing a game object in your scene and attaching the <code>RhomboidWorld</code> component.
					The shape of the world is described by the three axes, which in most cases should be orthogonal.
					You can then choose which of the three axes exhibit wrapping behavior, usually only one or two of them, though setting all three to wrap is also supported.</p>
				<p>The viewport will typically be associated with a camera, and so the easiest way to create a viewport is to add the <code>CameraViewport</code> component to the main camera.
					If the camera moves, you'll also want to add the <code>DynamicElementWrapper</code> component to keep the viewport confined to the bounds of the world,
					and the <code>DynamicViewport</code> component to guarantee that the viewport data is synchronized with the camera's transformation before any of the other wrap-around logic is executed.
					(Script execution orders are set by default to ensure that the various wrap-around components execute in the proper order.)</p>
				<p>Finally, you'll want to place game objects in your world that participate in wrapping behavior.
					The exact components you'll want to put on these game objects depends on precisely how they interact with the wrapping behavior.
					In general, you'll typically want to add one or more of the <code>*Element</code> components, one of the <code>*ElementWrapper</code> components, and one of the <code>*Bounds</code> components.</p>
				<p>Many of the components require a reference to either the world or viewport component.
					To make this easier, nest all of your wrapping game objects (including the camera/viewport) under the world game object.
					Then, on the world game object, add the <code>WorldProvider</code> and <code>ViewportProvider</code> components, and fill in the world and viewport fields on these two components.
					Upon play, all components that need a world or viewport reference will then be able to look up their game object hierarchy to find the first appropriate provider and pull a reference from it.
					Or to minimize startup cost, you can use the "Apply to All Children" button in the provider's inspector panel to set these references at edit-time.</p>
			</section>
		</section>
		<section class="chapter" id="worlds">
			<h2 class="section-head">Worlds</h2>
			<p>Worlds form the foundation of the Wrap-Around Worlds framework.
				They define the shape of the game environment, where the boundaries of the world are, and what happens when elements within the world cross each boundary.</p>
			<section id="rhomboid-world">
				<h3 class="section-head">Rhomboid World</h2>
				<p>The rhomboid world is in the shape of a rhomboid (more commonly known as a <a href="https://en.wikipedia.org/wiki/Parallelepiped" target="external">parallelepiped</a>,
					but I found that name to be tedious to type and pronounce).
					It is defined by three axes, none of which should be colinear.
					In the most common case where all three axes are perpendicular to each other, the result is a simple box.</p>
				<p>The length of each axis determines the size of the world along that axis.
					For axes that do not wrap, this length is irrelevant, and only the direction of the vector is important.
					For axes that do wrap, this length determines how far an object can travel before it must wrap around to the other side of the world, and how far it must move to wrap correctly.
					It also determines how far away virtual copies of an element must be placed relative to the original when such copies are needed outside of the strict bounds of the world.</p>
			</section>
		</section>
		<section class="chapter" id="viewports">
			<h2 class="section-head">Viewports</h2>
			<p>Viewports represent a particularly shaped view of the world.
				As long as the viewport remains entirely focused on the interior of a world, it behaves conventionally, operating similarly to a camera in the abstract sense.
				However, when part or all of a viewport's volume extends beyond the boundaries of the world to which it is applied, it enables special behavior applicable to the wrapping nature of the world.</p>
			<p>The most frequent use of viewports are for rendering purposes.
				When the wrapping behavior should affect what is rendered, a viewport attached to the camera used for rendering will offer the desired functionality.
				In a world that wraps around along a particular edge, when the camera is looking at that boundary, by default the boundary will be painfully obvious,
				because nothing even exists beyond the boundary according to convential spatial relations of game objects.
				A player character may be explicitly wrapped around when they step across that boundary, and the camera will naturally follow them once that happens,
				but if the character is only near the edge by hasn't yet crossed it, much of the screen will not have anything rendered to it, except perhaps the sky box.</p>
			<p>To correct this, a viewport can figure out what <em>would</em> appear in that empty space if the opposite side of the world were hooked up to the boundary currently being viewed.
				Individual elements that participate in rendering (such as meshes and lights) can then alter their behavior or duplicate themselves as necessary to ensure that
				everything within the boundaries of the viewport look the way one would expect them to look if there were no seams between wrapped world edges.</p>
			<p>In addition to the obvious use with rendering and cameras, viewports can also be used for handling game mechanics that need to operate across wrapping world boundaries,
				but only in specific regions at a time, for example, within the vicinity of the player character.
				Since these needs will vary greatly from game to game, no specific components exist in this framework to enable such behavior,
				but the viewport is likely to form the basis for determining which objects need to have the game-specific logic applied.</p>
		</section>
		<section class="chapter" id="ghosts">
			<h2 class="section-head">Ghosts &amp; Ghost Regions</h2>
			<p>An important concept within this framework is that of the canonical world volume, and canonical instances of game objects within the world.
				These canonical volumes and objects represent the one true instance of the game world's current state.
				However, when embedding a wrap-around world into a modern 3D engine with standard rendering and physics, there are cases, as in the viewport example above,
				when virtual copies of objects need to be placed outside of the canonical boundaries of the world
				in order for things to appear and behave correctly according to the logic of wrapped world edges.
				I refer to these virtual objects as <em>ghosts</em>, and they exist within virtual copies of the world volume I call <em>ghost regions</em>.</p>
			<p>There will always only be one canonical world volume, and one canonical instance of each game object in the world, but there can be zero or more ghosts and ghost regions.
				Note, however, that for each canonical game object, there can be at most one ghost within each ghost region.
				Since a ghost region represents a virtual copy of the world, there would be no reason for a single object to have more than one ghost within that particular ghost region.
				Accordingly, each [non-transient] ghost is aware of which ghost region it belongs to.</p>
			<p>Ghost regions are determined at runtime by whatever rules are appropriate.
				Currently, <em>visible</em> ghost regions are determined by a viewport attached to a camera,
				and <em>physical</em> ghost regions are determined by the shape of the world and the maximum radius of any physics effect (such as a collider) that might cross a wrapped edge.</p>
			<p>When given a list of active ghost regions, each element component knows what to do with that list, and if, when, and how to instantiate ghosts of itself.
				For elements that can have non-transient ghosts, each element also keeps track of the list of all of its ghosts.
				Not all elements create actual ghost instances as game objects, however.
				Sometimes it is enough to simply enumerate the list of active ghost regions and perform the appropriate logic for each region.
				In effect, this represents the existence of transient ghosts being applied to these ghost regions, even though no actual objects wer instantiated.
				<a href="#renderable-elements">Renderable elements</a> are an example of this kind of object.</p>
			<p>While neither an element component nor a ghost class need to inherit from a common base class or implement a common interface,
				<code>GhostableElement&lt;TElement, TGhost&gt;</code> and <code>Ghost&lt;TElement, TGhost&gt;</code> are useful base classes from which to derive new elements and ghosts.
				Typically, there will be a one-to-one relation between element types and ghost types, except for those elements that don't need ghost instances, in which case there would be no ghost class.</p>
			<p>Usually, an element will need a prefab from which to construct a ghost at runtime.
				Since the ghost is intended to mimic the original object, simply cloning the object might seem like a viable approach, but there are a couple of reasons to avoid this.
				First, the canonical game object might include additional components that aren't relevant to the role that the ghost fills, and would merely result in unnecessary processing and memory usage.
				A <code>MeshRenderer</code> component on a rigidbody ghost isn't needed, for example, because the rigidbody dynamics will occur whether or not the the object is rendered.
				Secondly, some of these additional components might actually perform game-relevant actions and are likely not prepared to handle a situation where more than one instance of an element exists at once.
				For example, a game might display a total count of enemies active in the game world at any given time by counting all the game objects that have the <code>Enemy</code> component attached.
				If some of these enemies are standing near world boundaries and therefore have ghost instances of them floating around, you wouldn't want the enemy count to include these ghosts in the total.</p>
			<p>Therefore, it is preferable to minimize the ghost prefab to include only the components and child game objects that are relevant to the role of the ghost for each particular element.
				The element types supplied by the framework which need ghost prefabs include helper tools in their inspector panels to automatically generate ghost prefabs.
				They do this by cloning the game object in its current state, and then stripping off all the components and descendants that are deemed irrelevant.
				If for some reason you need to create your own ghost prefab manually or wish to adjust the auto-created prefab, you are free to do so.</p>
			<p>If you do not set the ghost prefab from the editor, then one will automatically be constructed at runtime.
				The cost for this is twofold:  For one, the startup time might be noticeably impacted if enough objects need to construct ghost prefabs, especially if they are deeply nested game objects.
				Secondly, multiple game objects that are essentially identical and could otherwise shared a single ghost prefab will instead all create individual ghost object templates.
				Such ghost templates are hidden within the hierarchy, but they will nonetheless take up additional memory.
				However, they are marked inactive, so they should not result in additional any extra time for event processing.</p>
		</section>
		<section class="chapter" id="elements">
			<h2 class="section-head">Elements</h2>
			<p>Elements are created by attaching components of the appropriate types to a game object and setting the world and/or viewport references to the proper instances.
				The choice of which components to attach depends on the way the game object is expected to interact with the wrapping world boundaries.
				You are free to attach more than one element type component to a single game object, if you need the behaviors of multiple element types.
				In this case, each element type will be managed completely separate from any others, including the assignment and instantiation of ghost prefabs.</p>
			<section id="renderable-elements">
				<h3 class="section-head">Renderable Elements</h3>
				<p>Attach the <code>RenderableElement</code> component when you want an object to be rendered in such a way that it appears to exist in the world with seamlessly connected wrapped boundaries.
					Every renderable element needs a reference to a viewport so that it can know when any of its ghosts might be visible.
					Given the design of the Unity rendering system, a renderable element does not need to create actual ghost instances, and so does not need a ghost prefab.
					Instead, it simply uses <code>UnityEngine.Graphics.DrawMesh()</code> function to render all meshes on this game object and any of its descendants.</p>
				<p>In most cases, you'll also want to include a <a href="#bounds">bounds component</a> of some form to encapsulate the object's visible volume.
					If this object cast shadows, you'll need to ensure that the bounds encapsulate even the largest space in which the shadow could possibly appear,
					if you want to avoid any case of shadows popping in near the edge of the viewport.</p>
				<p>If you need this object to be rendered with wrapping behavior by more than one camera,
					then you can simply attach multiple <code>RenderableElement</code> components to the object and assign each one a different viewport.</p>
			</section>
			<section id="light-elements">
				<h3 class="section-head">Light Elements</h3>
				<p>Attach the <code>LightElement</code> component when you want a dynamic light source (from point lights or spotlights) to illuminate objects and cast shadows across world boundaries.</p>
				<p>In most cases, you'll also want to include a <a href="#bounds">bounds component</a> of some form to encapsulate the light's area of effect.</p>
			</section>
			<section id="collider-elements">
				<h3 class="section-head">Collider Elements</h3>
				<p>Attach the <code>ColliderElement</code> component when you want a game object with static colliders to be able to collide with dynamic colliders across wrapped world boundarines.
					This component is equally effective for static colliders marked as triggers.
					Note that if you handle any of the <code>OnCollision*()</code> or <code>OnTrigger*()</code> events,
					you will likely need to take into account that one or even both of the colliding objects are ghosts.</p>
				<p>In most cases, you'll also want to include a <a href="#bounds">bounds component</a> of some form to encapsulate the objects collision volume.</p>
			</section>
			<section id="rigidbody-elements">
				<h3 class="section-head">Rigidbody Elements</h3>
				<p>Attach the <code>RigidbodyElement</code> component when you want a game object with a rigidbody and dynamic colliders to be able to collide with other colliders across wrapped world boundarines.
					This component is equally effective for dynamic colliders marked as triggers.
					Note that if you handle any of the <code>OnCollision*()</code> or <code>OnTrigger*()</code> events,
					you will likely need to take into account that one or even both of the colliding objects are ghosts.</p>
				<p>In most cases, you'll also want to include a <a href="#bounds">bounds component</a> of some form to encapsulate the objects collision volume.</p>
			</section>
		</section>
		<section class="chapter" id="Wrappers">
			<h2 class="section-head">Wrappers</h2>
			<p>When you have a game object that moves and could potentially completely cross a wrapped world boundary, you will nearly always want to put a wrapper component of some form on it.
				Wrapper components simply check an object's position, and if it is outside of the bounds of the world, it will transform the object appropriately to bring back within the world's bounds.</p>
				There are three different wrappers to choose from.</p>
			<p>Use the <code>DynamicElementWrapper</code> component when the object is moved through scripts and only needs to be confined to the world boundaries before each rendered frame.
				The confinement calculations will occur during the component's <code>LateUpdate()</code> event.</p>
			<p>Use the <code>DynamicElementFixedUpdateWrapper</code> component when the object is moved through scripts but needs to be confined to the world boundaries during every fixed physics step.
				The confinement calculations will occur during the component's <code>FixedUpdate()</code> event.</p>
			<p>Use the <code>RigidbodyWrapper</code> component when the object is a rigidbody that moves due to the physics system.
				The confinement calculations will occur during the component's <code>FixedUpdate()</code> event as with the <code>DynamicElementFixedUpdateWrapper</code> component,
				but will be more optimally to the rigidbody's position and rotation fields directly, rather than to those of the transform component.</p>
		</section>
		<section class="chapter" id="bounds">
			<h2 class="section-head">Bounds</h2>
			<p>Not to be confused with <code>UnityEngine.Bounds</code> which are specifically axis-aligned bounding boxes,
				bounds in the wrap-around framework are abstract bounding volumes that could have a variety of shapes.
				Their primary purpose is to enable a simple double-dispatch system for determining intersections between elements/ghosts and worlds/viewports,
				for any combination of element/ghost shape and world/viewport shape.</p>
			<p>Bounds supplied by the Wrap-Around Worlds framework come in three main varieties.
				Point bounds are zero-extent bounds at a particular location relative to the game object transform.
				Sphere bounds are similar, but include a radius to define the size of a sphere centered at a particular location.
				Axis aligned box bounds likewise are centered on a location, but use x, y, and z extents to define a box.
				Local origin bounds are essentially a simplification of point bounds always located at a game objects local origin of (0, 0, 0).</p>
			<p>In addition to the various shapes, bounds come in different forms depending on if an object's scale and/or rotation is guaranteed to be constant.
				When one or both of these attributes is constant, optimizations can be made to make bounds-related calculations more efficient.</p>
			<p>By default, bounded elements will auto-compute their bounds at runtime.
				Each type of bounded element has its own method of doing so,
				but this will usually involve inspecting the relevant components and descendant game objects.
				For example, a rigidbody element will examine the collider components and create a bounding volume that encompasses all of the relevant collider bounding volumes.
			<p>If an axis aligned box is requested, then a fixed rotation is required.
				A fixed scale is optional for any type of bounding volume.</p>
			<p>If the automatic calculation of a bounds is not ideal, a bounds provider component can be added to the game object and configured.
				Then set the bounded element's bounds type to "Manual", and set the provided field to the bounds provider just configured.</p>
		</section>
		<section class="chapter" id="providers-consumers">
			<h2 class="section-head">Providers &amp; Consumers</h2>
			<p>Many of the components used within this framework require references to a world and/or a viewport in order to function.
				And there could be many such game objects within a scene, possibly placed by hand depending on the nature of the game and the scene.
				Setting all of the world and viewport references can quickly get tedious, so a system of providers and consumers has been implemented to ease this difficulty.</p>
			<p>All objects that require a world or viewport reference implement the <code>IWorldConsumer</code> or <code>IViewportConsumer</code> interface.
				An ancestor game object can then have a <code>WorldProvider</code> component and/or a <code>ViewportProvider</code> component added to it,
				and each provider can be provided with the proper world or viewport reference.
				(If the provider component has a sibling component of the needed type, then this reference will be automatically initialized with this sibling component.)</p>
			<p>This then provides two avenues for initializing all those consumers.
				First, within each of those consumers' <code>Start()</code> event, they will check if their world/viewport reference is null.
				If it is then the game object hierarchy is searched upward for the first instance of the provider of the needed type.
				If such a provider is found, then the reference that is stored is used to initialize the consumer's own reference.
				If no such provider is found, then an exception is thrown and the component is disabled.</p>
			<p>Secondly, these references can be applied from within the editor in order to save processing time during startup.
				Simply select the provider in the scene hierarchy, and you should find two buttons within the provider component's inspector panel, "Apply to Unset Children" and "Apply to All Children".
				The first button will search all descendants for consumers of the relevant type and will use the provider's reference to initialize any of them that do not already have a reference set.
				The latter button is the same, but also overwrites the reference sof any consumers that already had their references set.</p>
		</section>
		<section class="chapter" id="execution-order">
			<h2 class="section-head">Execution Order</h2>
			<p>Due to various transform dependencies between the miscellaneous wrap-around components,
				certain script execution orders are necessary in order to avoid transient single frame glitches with rendering and physics.
				Upon importing the framework, these execution orders will be automatically set,
				but if they need to be adjusted, or additional scripts related to wrap-around behavior are written, here are the general rules and motivations:</p>
			<p>World scripts should execute first.  This is predominately so that a world's <code>Start()</code> event is processed before any other wrap-around component,
				since worlds are the basis upon which all other wrap-around behavior is defined.</p>
			<p>Viewport scripts come second.  Initialization code is likely to reference a world, so must come after the world has been initialized.</p>
			<p>Components that affect game object transforms, generally for the purpose of confining those objects to the bounds of the world, follow next.
				The <code>DynamicViewport</code> component has a special place immediately after this group, recalculating the viewport bounds after it has potentially had its transform updated,
				but before any later components evaluate their own transforms against the viewport's bounds.</p>
			<p>After these canonical game objects have had their transforms processed and viewports have been update, ghosts can then execute,
				updating their transforms to match those of their originating game objects.</p>
			<p>Finally, the canonical objects can be processed, checking if they need to instantiate any new ghosts.</p>
		</section>
		<section class="chapter" id="tile-based">
			<h2 class="section-head">Integration with Tile-Based Worlds</h2>
			<p>If you also have access to the Tile-Based Worlds framework and import
				<a href="Experilous/Packages/Tile-Based Wrap-Around Integration - With Examples.unitypackage">Tile-Based Wrap-Around Integration&#8203;.unitypackage</a>,
				then you will obtain some tools that can improve the integration of the functionalities of these two frameworks.</p>
			<p>At present, the only addition is a different world type that derives from <code>RhomboidWorldBase</code>, so it unsuprisingly behaves just like the rhomboid world described above.
				But instead of having to manually configure its shape, you only need to supply a <code>Surface</code> asset generated by the Tile-Based Worlds framework, and it will work out the world shape automatically.</p>
			<p>Beyond that, if you are generating meshes and prefabs for your tile-based worlds,
				you will probably want to ensure that the mesh generator uses subdivided chunks of the world to create multiple meshs,
				and that the prefab assigned to the prefab generator includes the relevant element components described above (most likely just the <code>RenderableElement</code> component).
				This will allow the wrapping information contained with the world topology to apply not just when enumerating topology element neighbors,
				but also when rendering the world and applying physics, which is naturally ideal.</p>
		</section>
	</body>
</html>
