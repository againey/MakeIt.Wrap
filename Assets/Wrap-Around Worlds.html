<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>Wrap-Around Worlds - Manual - by Experilous</title>
		<style type="text/css">
			<!--/*--><![CDATA[/*><!--*/
			html
			{
				margin: 0;
				padding: 0;
			}
			
			body
			{
				margin: 0 auto;
				padding: 36pt 72pt;
				max-width: 540pt;
			}
			
			section
			{
				margin: 0;
				padding: 0;
			}
			
			h1
			{
				margin: 0;
				padding: 0;
				font-size: 200%;
			}
			
			h2
			{
				font-size: 175%;
			}
			
			h3
			{
				font-size: 150%;
			}
			
			h4
			{
				font-size: 125%;
			}
			
			h1 div.title
			{
				font-size: 100%;
			}
			
			h1 div.subtitle
			{
				font-size: 75%;
				margin-left: 18pt;
			}
			
			section.chapter:first-of-type
			{
				counter-reset: section;
			}
			
			section.chapter
			{
				counter-increment: section;
			}
			
			section.chapter section:first-of-type
			{
				counter-reset: section;
			}

			section.chapter section
			{
				counter-increment: section;
			}
			
			*.section-head:before
			{
				content: counters(section, ".") ". ";
			}
			
			dt
			{
				display: list-item;
				list-style-type: disc;
				margin-left: 1em;
				font-weight: bold;
				font-style: italic;
			}
			/*]]>*/-->
		</style>
	</head>
	<body>
		<section id="introduction">
			<h1>
				<div class="title">Wrap-Around Worlds, by <a href="http://experilous.com" target="experilous">Experilous</a></div>
				<div class="subtitle">User's Manual</div>
			</h1>
			<p>Wrap-Around Worlds is a framework for Unity to aid in...<p>
		</section>
		<section id="contents">
			<h2>Contents</h2>
			<ol>
				<li><a href="#quick-start">Quick Start</a></li>
					<ol>
						<li><a href="#examples">Example Scenes</a></li>
						<li><a href="#create-your-own">Creating Your Own World</a></li>
					</ol>
				<li><a href="#worlds">Worlds</a>
					<ol>
						<li><a href="#rhomboid-world">Rhomboid World</a></li>
					</ol>
				</li>
				<li><a href="#viewports">Viewports</a></li>
				<li><a href="#ghosts">Ghosts &amp; Ghost Regions</a></li>
				<li><a href="#elements">Elements</a>
					<ol>
						<li><a href="#renderable-elements">Renderable Elements</a></li>
						<li><a href="#light-elements">Light Elements</a></li>
						<li><a href="#collider-elements">Collider Elements</a></li>
						<li><a href="#rigidbody-elements">Rigidbody Elements</a></li>
					</ol>
				</li>
				<li><a href="#wrappers">Wrappers</a></li>
				<li><a href="#bounds">Bounds</a></li>
				<li><a href="#providers-consumers">Providers &amp; Consumers</a></li>
				<li><a href="#tile-based">Integration with Tile-Based Worlds</a></li>
			</ol>
		</section>
		<section class="chapter" id="quick-start">
			<h2 class="section-head">Quick Start</h2>
			<section id="examples">
				<h2 class="section-head">Example Scenes</h2>
				<p>Included in this package are example scenes to demonstrate some of the worlds that the framework can manage.
					These scenes can be found in the <a href="Experilous/Examples/Wrap-Around Worlds/">&lt;project&gt;/Assets/Experilous/Examples/Wrap-Around Worlds/</a> folder.</p>
				<dl>
					<dt><a href="Experilous/Examples/Wrap-Around Worlds/Asteroids.unity">Asteroids</a></dt>
					<dd>A small square world with dynamic rigidbody elements, some of which are able to collide with each other across world boundaries.</dd>
					<dt><a href="Experilous/Examples/Wrap-Around Worlds/RPG.unity">RPG</a></dt>
					<dd>A small square world with a simple player model and scattered bushes, with lighting and shadows that are able to wrap around across world boundaries.</dd>
				</dl>
				<p>If you also have access to the Tile-Based Worlds framework and import
					<a href="Experilous/Packages/Tile-Based Wrap-Around Integration - With Examples.unitypackage">Tile-Based Wrap-Around Integration - With Examples&#8203;.unitypackage</a>,
					then you will gain access to a few more example scenes.</p>
				<dl>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Planar Square Vertical Wrap.unity">Planar Square Vertical Wrap</a></dt>
					<dd>A planar surface with square tiles.  The world wraps around across the top and bottom edges.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Planar Square Full Wrap.unity">Planar Square Full Wrap</a></dt>
					<dd>A large planar surface with square tiles.  The world wraps around both across the top and bottom edges and across the left and right edges.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Planar Hex Horizontal Wrap.unity">Planar Hex Horizontal Wrap</a></dt>
					<dd>A planar surface with hexagonal tiles arranged at an angle to create a parallelogram-shaped world.  The world wraps around across the left and right edges.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Planar Hex Full Wrap.unity">Planar Hex Full Wrap</a></dt>
					<dd>A wide planar surface with hexagonal tiles arranged at an angle to create a parallelogram-shaped world.  The world wraps around both across the top and bottom edges and across the left and right edges.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Planar Random Full Wrap.unity">Planar Random Full Wrap</a></dt>
					<dd>A planar surface with randomly shaped tiles which began as hexagonal tiles before being randomized.  The world wraps around both across the top and bottom edges and across the left and right edges.</dd>
				</dl>
			</section>
			<section id="create-your-own">
				<h2 class="section-head">Creating Your Own World</h2>
				<p>To create your own scene containing a wrap-around world, you need three basic items:  a world, a viewport, and one or more elements which participate with the wrapping behavior in some manner.</p>
				<p>The world can be created by placing a game object in your scene and attaching the <code>RhomboidWorld</code> component.
					The shape of the world is described by the three axes, which in most cases should be orthogonal.
					You can then choose which of the three axes exhibit wrapping behavior, usually only one or two of them, though setting all three to wrap is also supported.</p>
				<p>The viewport will typically be associated with a camera, and so the easiest way to create a viewport is to add the <code>CameraViewport</code> component to the main camera.
					If the camera moves, you'll also want to add the <code>DynamicElementWrapper</code> component to keep the viewport confined to the bounds of the world,
					and the <code>DynamicViewport</code> component to guarantee that the viewport data is synchronized with the camera's transformation before any of the other wrap-around logic is executed.
					(Script execution orders are set by default to ensure that the various wrap-around components execute in the proper order.)</p>
				<p>Finally, you'll want to place game objects in your world that participate in wrapping behavior.
					The exact components you'll want to put on these game objects depends on precisely how they interact with the wrapping behavior.
					In general, you'll typically want to add one or more of the <code>*Element</code> components, one of the <code>*ElementWrapper</code> components, and one of the <code>*Bounds</code> components.</p>
				<p>Many of the components require a reference to either the world or viewport component.
					To make this easier, nest all of your wrapping game objects (including the camera/viewport) under the world game object.
					Then, on the world game object, add the <code>WorldProvider</code> and <code>ViewportProvider</code> components, and fill in the world and viewport fields on these two components.
					Upon play, all components that need a world or viewport reference will then be able to look up their game object hierarchy to find the first appropriate provider and pull a reference from it.
					Or to minimize startup cost, you can use the "Apply to All Children" button in the provider's inspector panel to set these references at edit-time.</p>
			</section>
		</section>
		<section class="chapter" id="worlds">
			<h2 class="section-head">Worlds</h2>
			<p>Worlds form the foundation of the Wrap-Around Worlds framework.
				They define the shape of the game environment, where the boundaries of the world are, and what happens when elements within the world cross each boundary.</p>
			<section id="rhomboid-world">
				<h3 class="section-head">Rhomboid World</h2>
				<p>The rhomboid world is in the shape of a rhomboid (more commonly known as a <a href="https://en.wikipedia.org/wiki/Parallelepiped" target="external">parallelepiped</a>,
					but I found that name to be tedious to type and pronounce).
					It is defined by three axes, none of which should be colinear.
					In the most common case where all three axes are perpendicular to each other, the result is a simple box.</p>
				<p>The length of each axis determines the size of the world along that axis.
					For axes that do not wrap, this length is irrelevant, and only the direction of the vector is important.
					For axes that do wrap, this length determines how far an object can travel before it must wrap around to the other side of the world, and how far it must move to wrap correctly.
					It also determines how far away virtual copies of an element must be placed relative to the original when such copies are needed outside of the strict bounds of the world.</p>
			</section>
		</section>
		<section class="chapter" id="viewports">
			<h2 class="section-head">Viewports</h2>
			<p>Viewports represent a particularly shaped view of the world.
				As long as the viewport remains entirely focused on the interior of a world, it behaves conventionally, operating similarly to a camera in the abstract sense.
				However, when part or all of a viewport's volume extends beyond the boundaries of the world to which it is applied, it enables special behavior applicable to the wrapping nature of the world.</p>
			<p>The most frequent use of viewports are for rendering purposes.
				When the wrapping behavior should affect what is rendered, a viewport attached to the camera used for rendering will offer the desired functionality.
				In a world that wraps around along a particular edge, when the camera is looking at that boundary, by default the boundary will be painfully obvious,
				because nothing even exists beyond the boundary according to convential spatial relations of game objects.
				A player character may be explicitly wrapped around when they step across that boundary, and the camera will naturally follow them once that happens,
				but if the character is only near the edge by hasn't yet crossed it, much of the screen will not have anything rendered to it, except perhaps the sky box.</p>
			<p>To correct this, a viewport can figure out what <em>would</em> appear in that empty space if the opposite side of the world were hooked up to the boundary currently being viewed.
				Individual elements that participate in rendering (such as meshes and lights) can then alter their behavior or duplicate themselves as necessary to ensure that
				everything within the boundaries of the viewport look the way one would expect them to look if there were no seams between wrapped world edges.</p>
			<p>In addition to the obvious use with rendering and cameras, viewports can also be used for handling game mechanics that need to operate across wrapping world boundaries,
				but only in specific regions at a time, for example, within the vicinity of the player character.
				Since these needs will vary greatly from game to game, no specific components exist in this framework to enable such behavior,
				but the viewport is likely to form the basis for determining which objects need to have the game-specific logic applied.</p>
		</section>
		<section class="chapter" id="ghosts">
			<h2 class="section-head">Ghosts &amp; Ghost Regions</h2>
			<p>An important concept within this framework is that of the canonical world volume, and canonical instances of game objects within the world.
				These canonical volumes and objects represent the one true instance of the game world's current state.
				However, when embedding a wrap-around world into a modern 3D engine with standard rendering and physics, there are cases, as in the viewport example above,
				when virtual copies of objects need to be placed outside of the canonical boundaries of the world
				in order for things to appear and behave correctly according to the logic of wrapped world edges.
				I refer to these virtual objects as <em>ghosts</em>, and they exist within virtual copies of the world volume I call <em>ghost regions</em>.</p>
			<p>There will always only be one canonical world volume, and one canonical instance of each game object in the world, but there can be zero or more ghosts and ghost regions.
				Note, however, that for each canonical game object, there can be at most one ghost within each ghost region.
				Since a ghost region represents a virtual copy of the world, there would be no reason for a single object to have more than one ghost within that particular ghost region.
				Accordingly, each [non-transient] ghost is aware of which ghost region it belongs to.</p>
			<p>Ghost regions are determined at runtime by whatever rules are appropriate.
				Currently, <em>visible</em> ghost regions are determined by a viewport attached to a camera,
				and <em>physical</em> ghost regions are determined by the shape of the world and the maximum radius of any physics effect (such as a collider) that might cross a wrapped edge.</p>
			<p>When given a list of active ghost regions, each element component knows what to do with that list, and if, when, and how to instantiate ghosts of itself.
				For elements that can have non-transient ghosts, each element also keeps track of the list of all of its ghosts.
				Not all elements create actual ghost instances as game objects, however.
				Sometimes it is enough to simply enumerate the list of active ghost regions and perform the appropriate logic for each region.
				In effect, this represents the existence of transient ghosts being applied to these ghost regions, even though no actual objects wer instantiated.
				<a href="#renderable-elements">Renderable elements</a> are an example of this kind of object.</p>
			<p>While neither an element component nor a ghost class need to inherit from a common base class or implement a common interface,
				<code>GhostableElement&lt;TElement, TGhost&gt;</code> and <code>Ghost&lt;TElement, TGhost&gt;</code> are useful base classes from which to derive new elements and ghosts.
				Typically, there will be a one-to-one relation between element types and ghost types, except for those elements that don't need ghost instances, in which case there would be no ghost class.</p>
			<p>Usually, an element will need a prefab from which to construct a ghost at runtime.
				Since the ghost is intended to mimic the original object, simply cloning the object might seem like a viable approach, but there are a couple of reasons to avoid this.
				First, the canonical game object might include additional components that aren't relevant to the role that the ghost fills, and would merely result in unnecessary processing and memory usage.
				A <code>MeshRenderer</code> component on a rigidbody ghost isn't needed, for example, because the rigidbody dynamics will occur whether or not the the object is rendered.
				Secondly, some of these additional components might actually perform game-relevant actions and are likely not prepared to handle a situation where more than one instance of an element exists at once.
				For example, a game might display a total count of enemies active in the game world at any given time by counting all the game objects that have the <code>Enemy</code> component attached.
				If some of these enemies are standing near world boundaries and therefore have ghost instances of them floating around, you wouldn't want the enemy count to include these ghosts in the total.</p>
			<p>Therefore, it is preferable to minimize the ghost prefab to include only the components and child game objects that are relevant to the role of the ghost for each particular element.
				The element types supplied by the framework which need ghost prefabs include helper tools in their inspector panels to automatically generate ghost prefabs.
				They do this by cloning the game object in its current state, and then stripping off all the components and descendants that are deemed irrelevant.
				If for some reason you need to create your own ghost prefab manually or wish to adjust the auto-created prefab, you are free to do so.</p>
		</section>
		<section class="chapter" id="elements">
			<h2 class="section-head">Elements</h2>
			<p>Elements are created by attaching components of the appropriate types to a game object and setting the world and/or viewport references to the proper instances.
				The choice of which components to attach depends on the way the game object is expected to interact with the wrapping world boundaries.
				You are free to attach more than one element type component to a single game object, if you need the behaviors of multiple element types.
				In this case, each element type will be managed completely separate from any others, including the assignment and instantiation of ghost prefabs.</p>
			<section id="renderable-elements">
				<h3 class="section-head">Renderable Elements</h3>
				<p>Attach the <code>RenderableElement</code> component when you want an object to be rendered in such a way that it appears to exist in the world with seamlessly connected wrapped boundaries.
					Every renderable element needs a reference to a viewport so that it can know when any of its ghosts might be visible.
					Given the design of the Unity rendering system, a renderable element does not need to create actual ghost instances, and so does not need a ghost prefab.
					Instead, it simply uses <code>UnityEngine.Graphics.DrawMesh()</code> function to render all meshes on this game object and any of its descendants.</p>
				<p>In most cases, you'll also want to include a <a href="#bounds">bounds component</a> of some form to encapsulate the object's visible volume.
					If this object cast shadows, you'll need to ensure that the bounds encapsulate even the largest space in which the shadow could possibly appear,
					if you want to avoid any case of shadows popping in near the edge of the viewport.</p>
				<p>If you need this object to be rendered with wrapping behavior by more than one camera,
					then you can simply attach multiple <code>RenderableElement</code> components to the object and assign each one a different viewport.</p>
			</section>
			<section id="light-elements">
				<h3 class="section-head">Light Elements</h3>
				<p>Attach the <code>LightElement</code> component when you want a dynamic light source (from point lights or spotlights) to illuminate objects and cast shadows across world boundaries.</p>
				<p>In most cases, you'll also want to include a <a href="#bounds">bounds component</a> of some form to encapsulate the light's area of effect.</p>
			</section>
			<section id="collider-elements">
				<h3 class="section-head">Collider Elements</h3>
				<p>Attach the <code>ColliderElement</code> component when you want a game object with static colliders to be able to collide with dynamic colliders across wrapped world boundarines.
					This component is equally effective for static colliders marked as triggers.
					Note that if you handle any of the <code>OnCollision*()</code> or <code>OnTrigger*()</code> events,
					you will likely need to take into account that one or even both of the colliding objects are ghosts.</p>
				<p>In most cases, you'll also want to include a <a href="#bounds">bounds component</a> of some form to encapsulate the objects collision volume.</p>
			</section>
			<section id="rigidbody-elements">
				<h3 class="section-head">Rigidbody Elements</h3>
				<p>Attach the <code>RigidbodyElement</code> component when you want a game object with a rigidbody and dynamic colliders to be able to collide with other colliders across wrapped world boundarines.
					This component is equally effective for dynamic colliders marked as triggers.
					Note that if you handle any of the <code>OnCollision*()</code> or <code>OnTrigger*()</code> events,
					you will likely need to take into account that one or even both of the colliding objects are ghosts.</p>
				<p>In most cases, you'll also want to include a <a href="#bounds">bounds component</a> of some form to encapsulate the objects collision volume.</p>
			</section>
		</section>
		<section class="chapter" id="Wrappers">
			<h2 class="section-head">Wrappers</h2>
			<p>When you have a game object that moves and could potentially completely cross a wrapped world boundary, you will nearly always want to put a wrapper component of some form on it.
				Wrapper components simply check an object's position, and if it is outside of the bounds of the world, it will transform the object appropriately to bring back within the world's bounds.</p>
				There are three different wrappers to choose from.</p>
			<p>Use the <code>DynamicElementWrapper</code> component when the object is moved through scripts and only needs to be confined to the world boundaries before each rendered frame.
				The confinement calculations will occur during the component's <code>LateUpdate()</code> event.</p>
			<p>Use the <code>DynamicElementFixedUpdateWrapper</code> component when the object is moved through scripts but needs to be confined to the world boundaries during every fixed physics step.
				The confinement calculations will occur during the component's <code>FixedUpdate()</code> event.</p>
			<p>Use the <code>RigidbodyWrapper</code> component when the object is a rigidbody that moves due to the physics system.
				The confinement calculations will occur during the component's <code>FixedUpdate()</code> event as with the <code>DynamicElementFixedUpdateWrapper</code> component,
				but will be more optimally to the rigidbody's position and rotation fields directly, rather than to those of the transform component.</p>
		</section>
		<section class="chapter" id="bounds">
			<h2 class="section-head">Bounds</h2>
			<p>Not to be confused with <code>UnityEngine.Bounds</code> which are specifically axis-aligned bounding boxes,
				bounds in the wrap-around framework are abstract bounding volumes that could have a variety of shapes.
				Their primary purpose is to enable a simple double-dispatch system for determining intersections between elements/ghosts and worlds/viewports,
				for any combination of element/ghost shape and world/viewport shape.</p>
			<p>The four implemented bounds currently are <code>PointBounds</code> which has no volume at all,
				<code>SphereBounds</code> and <code>StaticSphereBounds</code> which both have a spherical volume defined by a radius,
				and <code>AxisAlignedBoxBounds</code>, which is equivalent in purpose to <code>UnityEngine.Bounds</code>.</p>
			<p>For the three non-point bounds, code within the <code>Start()</code> will check if the pre-configured volumes are completely empty,
				and if so, will attempt to search for other components on the game object from which a proper bounds can be automatically computed.
				The difference between <code>SphereBounds</code> and <code>StaticSphereBounds</code> is that the latter will calculate the scaled radius based on the object's transform during <code>Start()</code>,
				and will use this cached radius directly for all future computations.
				The former will recompute the scaled radius every time it is needed, which is appropriate for an object that has a scale that can change dynamically.</p>
		</section>
		<section class="chapter" id="providers-consumers">
			<h2 class="section-head">Providers &amp; Consumers</h2>
			<p>Many of the components used within this framework require references to a world and/or a viewport in order to function.
				And there could be many such game objects within a scene, possibly placed by hand depending on the nature of the game and the scene.
				Setting all of the world and viewport references can quickly get tedious, so a system of providers and consumers has been implemented to ease this difficulty.</p>
			<p>All objects that require a world or viewport reference implement the <code>IWorldConsumer</code> or <code>IViewportConsumer</code> interface.
				An ancestor game object can then have a <code>WorldProvider</code> component and/or a <code>ViewportProvider</code> component added to it,
				and each provider can be provided with the proper world or viewport reference.
				(If the provider component has a sibling component of the needed type, then this reference will be automatically initialized with this sibling component.)</p>
			<p>This then provides two avenues for initializing all those consumers.
				First, within each of those consumers' <code>Start()</code> event, they will check if their world/viewport reference is null.
				If it is then the game object hierarchy is searched upward for the first instance of the provider of the needed type.
				If such a provider is found, then the reference that is stored is used to initialize the consumer's own reference.
				If no such provider is found, then an exception is thrown and the component is disabled.</p>
			<p>Secondly, these references can be applied from within the editor in order to save processing time during startup.
				Simply select the provider in the scene hierarchy, and you should find two buttons within the provider component's inspector panel, "Apply to Unset Children" and "Apply to All Children".
				The first button will search all descendants for consumers of the relevant type and will use the provider's reference to initialize any of them that do not already have a reference set.
				The latter button is the same, but also overwrites the reference sof any consumers that already had their references set.</p>
		</section>
		<section class="chapter" id="tile-based">
			<h2 class="section-head">Integration with Tile-Based Worlds</h2>
			<p>If you also have access to the Tile-Based Worlds framework and import
				<a href="Experilous/Packages/Tile-Based Wrap-Around Integration - With Examples.unitypackage">Tile-Based Wrap-Around Integration&#8203;.unitypackage</a>,
				then you will obtain some tools that can improve the integration of the functionalities of these two frameworks.</p>
			<p>At present, the only addition is a different world type that derives from <code>RhomboidWorldBase</code>, so it unsuprisingly behaves just like the rhomboid world described above.
				But instead of having to manually configure its shape, you only need to supply a <code>Surface</code> asset generated by the Tile-Based Worlds framework, and it will work out the world shape automatically.</p>
			<p>Beyond that, if you are generating meshes and prefabs for your tile-based worlds,
				you will probably want to ensure that the mesh generator uses subdivided chunks of the world to create multiple meshs,
				and that the prefab assigned to the prefab generator includes the relevant element components described above (most likely just the <code>RenderableElement</code> component).
				This will allow the wrapping information contained with the world topology to apply not just when enumerating topology element neighbors,
				but also when rendering the world and applying physics, which is naturally ideal.</p>
		</section>
	</body>
</html>
